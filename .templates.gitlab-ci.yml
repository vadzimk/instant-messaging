.pgbackups-script-job-template:
  # common configuration to create or drop db and user
  needs:
    - set-variables-from-terraform-artifact
  variables:
    # must override empty variables in concrete jobs
    ENV_FILE_VARIABLE: ""
    DB_SCRIPT: ""
    SCRIPT_REMOTE_DIR: "/tmp/"
  before_script:
    - !reference [ .before-script-secrets-anchor ]
  script:
    - chmod 400 $WS_KEY # private key
    - |
      scp -o StrictHostKeyChecking=no -i $WS_KEY \
      "$DB_SCRIPT" \
      ubuntu@$WS_HOST:${SCRIPT_REMOTE_DIR}
    - |
      ssh -o StrictHostKeyChecking=no -i $WS_KEY ubuntu@$WS_HOST "
        chmod +x \"${SCRIPT_REMOTE_DIR}${DB_SCRIPT}\" &&
        docker cp \"${SCRIPT_REMOTE_DIR}${DB_SCRIPT}\" pgbackups:/ &&
        docker exec -i \
          -e POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\" \
          -e POSTGRES_USER=\"$POSTGRES_USER\" \
          -e TARGET_USER=\"$POSTGRES_APP_USER\" \
          -e TARGET_USER_PASSWORD=\"$POSTGRES_APP_PASSWORD\" \
          -e DATABASE_NAME=\"$POSTGRES_DB\" \
          -e DATABASE_HOST=\"$POSTGRES_HOST\" \
          -e DATABASE_PORT=\"$POSTGRES_PORT\" \
        pgbackups bash \"$DB_SCRIPT\"
      "

.build-image-job-template:
  image: docker:20.10.17
  variables:
    # using "docker" as the host is only possible if you alias the service below
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    SERVICE_NAME: "" # should override
    PATH_TO_DOCKER_CONTEXT: "." # should override
    PATH_TO_DOCKERFILE: "" # should override
    BASE_IMAGE: "" # should override, optional, base image to build from
  services:
    - name: docker:20.10.17-dind
      alias: docker
      command: [ "--tls=false" ]
  #  before_script: # of the concrete job must export PACKAGE_VERSION variable, here are the examples:
  #    - export PACKAGE_VERSION=$(cat path-to/package.json | jq -r .version)
  #    - export PACKAGE_VERSION=$(grep 'version' path-to/version.py | cut -d'"' -f2)
  script:
    # set image name and tag
    - export IMAGE_NAME="${CI_REGISTRY_IMAGE}/${SERVICE_NAME}"
    - echo "$PACKAGE_VERSION"
    - export IMAGE_TAG="${PACKAGE_VERSION}-${CI_PIPELINE_IID}" # Semantic Version with Build Metadata (MAJOR.MINOR.PATCH-BUILD)
    - echo "IMAGE_NAME_IMAGE_TAG_${SERVICE_NAME}=${IMAGE_NAME}:${IMAGE_TAG}"
    - echo "IMAGE_NAME_IMAGE_TAG_${SERVICE_NAME}=${IMAGE_NAME}:${IMAGE_TAG}" >> build.env
    # build image
    - export DOCKER_BUILDKIT=0  # allows networking during build
    - | # tag as latest, build-arg IMAGE_NAME_AND_TAG is optional
      docker build --build-arg BASE_IMAGE="$BASE_IMAGE" \
      -t "${IMAGE_NAME}" \
      -f "$PATH_TO_DOCKERFILE" "$PATH_TO_DOCKER_CONTEXT"
    - docker tag "${IMAGE_NAME}" "${IMAGE_NAME}:${IMAGE_TAG}" # tag as version
    # push image to container registry
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - echo "${IMAGE_NAME}:${IMAGE_TAG}"
    - docker push "${IMAGE_NAME}" # pushes latest
    - docker push "${IMAGE_NAME}:${IMAGE_TAG}" # pushes version
  artifacts: # by default uploaded to all following stages if not specified in dependencies
    name: "$CI_JOB_NAME"
    paths:
      - build.env
    reports:
      # In subsequent jobs, the environment variables defined in build.env are automatically available.
      dotenv: build.env # loaded in all subsequent jobs (must be relative to working directory of .gitlab-ci.yml)
