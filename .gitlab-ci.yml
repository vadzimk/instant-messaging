include:
  - local: .utils.gitlab-ci.yml
  - local: .templates.gitlab-ci.yml


# workflow:
#   rules:
#     - if: $CI_COMMIT_BRANCH != "master" && $CI_PIPELINE_SOURCE != "merge_request_event"
#       when: never
#     - when: always


variables:
  FLUSHCACHE: "false" # trigger job to produce cache always when $FLUSHCACHE == "true"


stages:
  - export-variables
  - prepare-test-db
  - build-base-test-images
  - build-test-images
  - test

set-variables-from-terraform-artifact:
  stage: export-variables
  variables:
    ARTIFACT_PROJECT_ID: "37029027"
    BRANCH: "master"
    JOB_NAME: "apply"
    PACKAGES: "jq curl"
    GIT_STRATEGY: none # no code will be checked out from repo
  before_script:
    - !reference [ .before-script-install-packages-anchor ]
  script: # https://docs.gitlab.com/ee/api/job_artifacts.html#download-a-single-artifact-file-from-specific-tag-or-branch
    # create variables
    - |
      curl --location -o ./ter_output.json \
      --header "PRIVATE-TOKEN: ${GITLAB_JOB_ARTIFACTS_API_ACCESS_TOKEN}" \
      -X GET https://gitlab.com/api/v4/projects/${ARTIFACT_PROJECT_ID}/jobs/artifacts/${BRANCH}/raw/ter_output.json?job=${JOB_NAME};
    - |
      {
        echo WEBSERVER_PRIVATE_IP=$(cat ter_output.json | jq -r '."webserver-private_ip".value');
        echo GITLAB_RUNNER_PRIVATE_IP=$(cat ter_output.json | jq -r '."gitlab-runner-private_ip".value');
      } >> terraform_output.env
  artifacts:
    reports:
      dotenv: terraform_output.env # its variables are available in all subsequent jobs as any other variables


drop-test-postgres-db-job:
  # Drop postgres database and postgres app user
  stage: prepare-test-db
  extends: .pgbackups-script-job-template
  variables:
    ENV_FILE_VARIABLE: ENV_TEST
    DB_SCRIPT: "drop-postgres-db.sh"


init-test-postgres-db-job:
  # Initialize postgres database and postgres app user
  stage: prepare-test-db
  extends: .pgbackups-script-job-template
  needs:
    - drop-test-postgres-db-job
  variables:
    ENV_FILE_VARIABLE: ENV_TEST
    DB_SCRIPT: "init-postgres-db.sh"


# init-production-postgres-job:
#   extends: .iniit-db-base
#   stage: install
#   variables:
#     ENV_FILE_VARIABLE: ENV_PROD


#.install-dependencies-job-template:
#  stage: install
#  image: python:3.10
#  variables:
#    # must override in concrete job
#    CHECKOUT_DIR: ""
#    CACHE_KEY: ""
#  before_script:
#    - *checkout-only-script
#  script:
#    - ls -htla
#    - cd "$CHECKOUT_DIR"
#    - pip install --no-cache-dir pipenv
#    - export PIPENV_VENV_IN_PROJECT=1
#    - pipenv install --ignore-pipfile --dev
#    - pipenv run pip list
#  cache:
#    key: "$CACHE_KEY"
#    paths:
#      - "${CHECKOUT_DIR}/.venv"
#    policy: push
#  rules:
#    - if: $FLUSHCACHE == "true"
#      when: always
#    - if: $FLUSHCACHE == "false"
#      changes:
#        - ${CHECKOUT_DIR}/Pipfile.lock
#        - ${CHECKOUT_DIR}/Pipfile
#      when: always
#    - if: $FLUSHCACHE == "false"
#      exists:
#        - "${CHECKOUT_DIR}/.venv"
#      when: never
#    - when: always # Fallback to ensure job runs if cache is not found


#install-backend-dependencies-job:
#  extends: .install-dependencies-job-template
#  variables:
#    CHECKOUT_DIR: "backend"
#    CACHE_KEY: "DEP-Backend-${CI_COMMIT_REF_SLUG}"
#
#
#install-telegram-bot-dependencies-job:
#  extends: .install-dependencies-job-template
#  variables:
#    CHECKOUT_DIR: "telegram_bot"
#    CACHE_KEY: "DEP-Bot-${CI_COMMIT_REF_SLUG}"



#test-backend-job:
#  stage: test
#  image: python:3.10
#  needs:
#    - job: install-server-dependencies-job
#      optional: true # if used cache
#    - init-test-postgres-job
#  variables:
#    ENV_FILE_VARIABLE: ENV_TEST
#  cache:
#    key: "DEP-Backend-${CI_COMMIT_REF_SLUG}"
#    paths:
#      - backend/.venv
#    policy: pull
#  services:
#    - name: redis:alpine
#  before_script:
#    # SPARSE CHECKOUT IS INCOMPATIBLE WITH CACHE RESTORATION,
#    # Sparse Checkout Behavior:
#    # The .venv folder is not part of the repository. When you run git sparse-checkout, only tracked files in CHECKOUT_DIR are included, excluding the cached .venv.
#    # Cache Restoration:
#    # The cache is restored to the working directory before sparse-checkout is applied. If sparse-checkout excludes CHECKOUT_DIR/.venv, it gets effectively removed.
#    - *export-env-vars-script
#    - *export-jwt-keys-script
#  script:
#    - cd backend
#    - source .venv/bin/activate
#    - export POSTGRES_HOST="$WS_HOST"
#    - alembic upgrade head
#    - uvicorn src.main:app --host 127.0.0.1 --port 8000 --workers=1 &
#    - BACKEND_PID=$!
#    - sleep 5
#    - python -m pytest -vv --junitxml=junit.xml
#  after_script:
#    - kill $BACKEND_PID
#  artifacts:
#    when: always
#    paths:
#      - backend/junit.xml
#    reports:
#      junit: backend/junit.xml
#  only:
#    changes:
#      - backend/**/*

# Build base images for test jobs:

build-test-backend-base-image-job:
  stage: build-base-test-images
  extends: .build-image-job-template
  variables:
    SERVICE_NAME: "backend_test_service_base"
    PATH_TO_DOCKER_CONTEXT: "./backend"
    PATH_TO_DOCKERFILE: "./backend/Dockerfile.test.base"
  before_script:
    - !reference [ .before-script-export-version-python-anchor ]
#  only:
#    changes:
#      - ${PATH_TO_DOCKER_CONTEXT}/Pipfile.lock
#      - ${PATH_TO_DOCKER_CONTEXT}/Pipfile

build-test-telegram-bot-base-image-job:
  stage: build-base-test-images
  extends: .build-image-job-template
  variables:
    SERVICE_NAME: "telegram_bot_test_service_base"
    PATH_TO_DOCKER_CONTEXT: "./telegram_bot"
    PATH_TO_DOCKERFILE: "./telegram_bot/Dockerfile.test.base"
  before_script:
    - !reference [ .before-script-export-version-python-anchor ]
#  only:
#    changes:
#      - ${PATH_TO_DOCKER_CONTEXT}/Pipfile.lock
#      - ${PATH_TO_DOCKER_CONTEXT}/Pipfile

# Build final images for test jobs:

build-test-backend-image-job:
  stage: build-test-images
  extends: .build-image-job-template
  variables:
    SERVICE_NAME: "backend_test_service"
    PATH_TO_DOCKER_CONTEXT: "./backend"
    PATH_TO_DOCKERFILE: "./backend/Dockerfile.test"
  before_script:
    - !reference [ .before-script-export-version-python-anchor ]
    - export BASE_IMAGE="IMAGE_NAME_IMAGE_TAG_${SERVICE_NAME}_base:latest"
#  only:
#    changes:
#      - backend/**/*

build-test-telegram-bot-image-job:
  stage: build-test-images
  extends: .build-image-job-template
  variables:
    SERVICE_NAME: "telegram_bot_test_service"
    PATH_TO_DOCKER_CONTEXT: "./telegram_bot"
    PATH_TO_DOCKERFILE: "./telegram_bot/Dockerfile.test"
  before_script:
    - !reference [ .before-script-export-version-python-anchor ]
    - export BASE_IMAGE="IMAGE_NAME_IMAGE_TAG_${SERVICE_NAME}_base:latest"
#  only:
#    changes:
#      - telegram_bot/**/*

test-backend-job:
  stage: test
  image: docker:20.10.17
  variables:
    # using "docker" as the host is only possible if you alias the service below
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    ENV_FILE_VARIABLE: ENV_TEST
  services:
    - name: docker:20.10.17-dind
      alias: docker
      command: [ "--tls=false" ]
  before_script:
    #    - *export-env-vars-script
    - !reference [ .before-script-secrets-anchor ]
    - !reference [ .before-script-jwt-anchor ]
  #    - echo "$IMAGE_NAME_IMAGE_TAG_backend_test_service"
  #    - echo "$IMAGE_NAME_IMAGE_TAG_backend_test_service"
  #    - echo "$IMAGE_NAME_IMAGE_TAG_telegram_bot_test_service"
  script:
    - export DOCKER_BUILDKIT=0  # allows networking during build
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    #    - ls -a
    #    - cat .env
    #    - docker container ls -a
    #    - docker image ls -a
    - docker-compose -f docker-compose.test.yml up # remove this, see the output of entrypoint, bc user table not found
    #    - docker-compose -f docker-compose.test.yml up -d
    - sleep 10 # wait to init containers
    #    - |
    #      echo "Waiting for backend service to be healthy..."
    #      timeout 60 sh -c 'until [ "$(docker inspect --format="{{.State.Health.Status}}" backend)" == "healthy" ]; do sleep 2; done' || exit 1
    #    - echo "backend service is healthy, proceeding..."
    #    - docker exec -i backend bash -c "ls -thal"
    #    - docker exec -i backend bash -c "tree -L 2"
    #    - docker exec -i backend bash -c "./docker-entrypoint.sh"
    - |
      docker exec -i backend bash -c "python -m pytest -vv -s --junitxml=junit.xml tests/api/test_api.py::test_signup_user";
      TEST_EXIT_CODE=$?;
      docker cp backend:junit.xml backend/junit.xml || echo "junit.xml not found";
      docker-compose -f docker-compose.test.yml down --volumes --remove-orphans --rmi all
      docker image prune --all --force
      exit $TEST_EXIT_CODE;
  artifacts:
    when: always
    paths:
      - backend/junit.xml
    reports:
      junit: backend/junit.xml
#  only:
#    changes:
#      - backend/**/*



#test-backend-job:
#  stage: test
#  image: docker:20.10.17
#  needs:
#    - job: install-server-dependencies-job
#      optional: true # if used cache
#    - init-test-postgres-job
#  variables:
#    ENV_FILE_VARIABLE: ENV_TEST
#  cache:
#    key: "DEP-Backend-${CI_COMMIT_REF_SLUG}"
#    paths:
#      - backend/.venv
#    policy: pull
#  services:
#    - name: redis:alpine
#  before_script:
#    # SPARSE CHECKOUT IS INCOMPATIBLE WITH CACHE RESTORATION,
#    # Sparse Checkout Behavior:
#    # The .venv folder is not part of the repository. When you run git sparse-checkout, only tracked files in CHECKOUT_DIR are included, excluding the cached .venv.
#    # Cache Restoration:
#    # The cache is restored to the working directory before sparse-checkout is applied. If sparse-checkout excludes CHECKOUT_DIR/.venv, it gets effectively removed.
#    - *export-env-vars-script
#    - *export-jwt-keys-script
#  script:
#    - cd backend
#    - source .venv/bin/activate
#    - export POSTGRES_HOST="$WS_HOST"
#    - alembic upgrade head
#    - uvicorn src.main:app --host 127.0.0.1 --port 8000 --workers=1 &
#    - BACKEND_PID=$!
#    - sleep 5
#    - python -m pytest -vv --junitxml=junit.xml
#  after_script:
#    - kill $BACKEND_PID
#  artifacts:
#    when: always
#    paths:
#      - backend/junit.xml
#    reports:
#      junit: backend/junit.xml
#  only:
#    changes:
#      - backend/**/*
#

#test-telegram-bot-job:
#  stage: test
#  image: python:3.10
#  needs:
#    - job: install-telegram-bot-dependencies-job
#      optional: true # if used cache
#  variables:
#    ENV_FILE_VARIABLE: ENV_TEST
#  cache:
#    key: "DEP-Bot-${CI_COMMIT_REF_SLUG}"
#    paths:
#      - telegram_bot/.venv
#    policy: pull
#  before_script:
#    - *export-env-vars-script
#  script:
#    # start services in docker compose for testing because services in separate jobs cannot communicate between each other
#    - echo "not implemented" && exit 1


#test-network:
#  stage: install
#  variables:
#    POSTGRES_HOST: 172.16.0.24
#    POSTGRES_PORT: 5432
#  before_script:
#    - |
#      apt-get update && apt-get install -y \
#      netcat-openbsd \
#      && apt-get clean \
#      && rm -rf /var/lib/apt/lists/*
#  script:
#    - nc -zv $WS_HOST "$POSTGRES_PORT"